### Eclipse Workspace Patch 1.0
#P HaloSMWExtension_SVN_HEAD
Index: extensions/SemanticForms/includes/SF_FormPrinter.inc
===================================================================
--- extensions/SemanticForms/includes/SF_FormPrinter.inc	(revision 3708)
+++ extensions/SemanticForms/includes/SF_FormPrinter.inc	(working copy)
@@ -1287,4 +1287,770 @@
     return array($text, $javascript_text);
   }
 
+  	//
+	// THE NEW FUNC
+	//
+
+	// help func
+	function toArray($data)
+	{
+		if(is_array($data) || is_object($data))
+		{
+			if(get_class($data) =='POMPage'){
+				$__pom = new POMPage($data->titel, $data->text);
+				$__result = array();
+				$__elementsIterator = $__pom->getElements()->listIterator();
+				$__result["page"] = $this->toArray ($__pcpPage);
+				$__cnt = 0;
+				while($__elementsIterator->hasNext()){
+					$__element = &$__elementsIterator->getNextNodeValueByReference();
+					$__array = $this->toArray($__element);
+					$__result["page"][get_class($__element)][$__cnt] = $__array;
+					$__cnt++;
+				}
+				return $__result;
+			}
+			$__result = array();
+
+			foreach ($data as $__key => $__value)
+			{
+				$__result[$__key] = $this->toArray($__value);
+			}
+			return $__result;
+		}
+		return $data;
+	}
+
+	/**
+	 * Prepares the SF data for searialization, including the SF definition and the template data (if any).
+	 *
+	 * @param string $form_def The definition of the SF.
+	 * @param boolean $source_is_page Set the flag if the source is a page.
+	 * @param string $existing_page_content The wiki markup of the page using the SF (with template data).
+	 * @param string $page_title The title of the page.
+	 * @return hashmap All fields of the SF with attributes and template data.
+	 */
+	public function formSerialize($form_def = '', $source_is_page = false, $existing_page_content = null, $page_title = null) {
+		//	public function formSerialize($form_def, $source_is_page, $existing_page_content = null, $page_title = null, $page_name_formula = null) {
+		global $wgRequest, $wgUser, $wgParser;
+		global $sfgTabIndex; // used to represent the current tab index in the form
+		global $sfgFieldNum; // used for setting various HTML IDs
+		global $sfgJSValidationCalls; // array of Javascript calls to determine if page can be saved
+
+		# define a var for all fields
+		$__fields = array();
+
+		// initialize some variables
+		$sfgTabIndex = 1;
+		$sfgFieldNum = 1;
+		$source_page_matches_this_form = false;
+		$form_page_title = NULL;		
+		// $form_is_partial is true if:
+		// (a) 'partial' == 1 in the arguments
+		// (b) 'partial form' is found in the form definition
+		// in the latter case, it may remain false until close to the end of
+		// the parsing, so we have to assume that it will become a possibility
+		$form_is_partial = false;
+		$new_text = "";
+
+		// if we have existing content and we're not in an active replacement
+		// situation, preserve the original content. We do this because we want
+		// to pass the original content on IF this is a partial form
+		// TODO: A better approach here would be to pass the revision id of the
+		// existing page content through the replace value, which would
+		// minimize the html traffic and would allow us to do a concurrent
+		// update check.  For now, we pass it through the hidden text field...
+
+		if (! $wgRequest->getCheck('partial')) {
+			$original_page_content = $existing_page_content;
+		} else {
+			$original_page_content = null;
+			if($wgRequest->getCheck('free_text')) {
+				$existing_page_content= $wgRequest->getVal('free_text');
+				$form_is_partial = true;
+			}
+		}
+
+		// disable all form elements if user doesn't have edit permission -
+		// two different checks are needed, because editing permissions can be
+		// set in different ways
+		// HACK - sometimes we don't know the page name in advance, but we still
+		// need to set a title here for testing permissions
+		if ($page_title == '')
+		$this->mPageTitle = Title::newFromText("Semantic Forms permissions test");
+		else
+		$this->mPageTitle = Title::newFromText($page_title);
+		if ($wgUser->isAllowed('edit') && $this->mPageTitle->userCanEdit()) {
+			$form_is_disabled = false;
+			$form_text = "";
+			// show "Your IP address will be recorded" warning if user is
+			// anonymous - wikitext for bolding has to be replaced with HTML
+			if ($wgUser->isAnon()) {
+				$anon_edit_warning = preg_replace("/'''(.*)'''/", "<strong>$1</strong>", wfMsg('anoneditwarning'));
+				$form_text .= "<p>$anon_edit_warning</p>\n";
+			}
+		} else {
+			$form_is_disabled = true;
+			// display a message to the user explaining why they can't edit the
+			// page - borrowed heavily from EditPage.php
+			if ( $wgUser->isAnon() ) {
+				$skin = $wgUser->getSkin();
+				$loginTitle = SpecialPage::getTitleFor( 'Userlogin' );
+				$loginLink = $skin->makeKnownLinkObj( $loginTitle, wfMsgHtml( 'loginreqlink' ) );
+				$form_text = wfMsgWikiHtml( 'whitelistedittext', $loginLink );
+			} else {
+				$form_text = wfMsg( 'protectedpagetext' );
+			}
+		}
+		$javascript_text = "";
+		$sfgJSValidationCalls = array();
+		$fields_javascript_text = "";
+
+		// Remove <noinclude> sections and <includeonly> tags from form definition
+		$form_def = StringUtils::delimiterReplace('<noinclude>', '</noinclude>', '', $form_def);
+		$form_def = strtr($form_def, array('<includeonly>' => '', '</includeonly>' => ''));
+
+		// parse wiki-text
+		// add '<nowiki>' tags around every triple-bracketed form definition
+		// element, so that the wiki parser won't touch it - the parser will
+		// remove the '<nowiki>' tags, leaving us with what we need
+		global $sfgDisableWikiTextParsing;
+		if (! $sfgDisableWikiTextParsing) {
+			$form_def = "__NOEDITSECTION__" . strtr($form_def, array('{{{' => '<nowiki>{{{', '}}}' => '}}}</nowiki>'));
+			$wgParser->mOptions = new ParserOptions();
+			$wgParser->mOptions->initialiseFromUser($wgUser);
+			$form_def = $wgParser->parse($form_def, $this->mPageTitle, $wgParser->mOptions)->getText();
+		}
+
+		// turn form definition file into an array of sections, one for each
+		// template definition (plus the first section)
+		$form_def_sections = array();
+		$start_position = 0;
+		$section_start = 0;
+		$free_text_was_included = false;
+		$free_text_preload_page = null;
+		$all_values_for_template = array();
+		// unencode and HTML-encoded representations of curly brackets and
+		// pipes - this is a hack to allow for forms to include templates
+		// that themselves contain form elements - the escaping is needed
+		// to make sure that those elements don't get parsed too early
+		$form_def = str_replace(array('&#123;', '&#124;', '&#125;'), array('{', '|', '}'), $form_def);
+		// and another hack - replace the 'free text' standard input with
+		// a field declaration to get it to be handled as a field
+		$form_def = str_replace('standard input|free text', 'field|<freetext>', $form_def);
+		while ($brackets_loc = strpos($form_def, "{{{", $start_position)) {
+			$brackets_end_loc = strpos($form_def, "}}}", $brackets_loc);
+			$bracketed_string = substr($form_def, $brackets_loc + 3, $brackets_end_loc - ($brackets_loc + 3));
+			$tag_components = explode('|', $bracketed_string);
+			$tag_title = trim($tag_components[0]);
+			if ($tag_title == 'for template' || $tag_title == 'end template') {
+				// create a section for everything up to here
+				$section = substr($form_def, $section_start, $brackets_loc - $section_start);
+				$form_def_sections[] = $section;
+				$section_start = $brackets_loc;
+			}
+			$start_position = $brackets_loc + 1;
+		} // end while
+		$form_def_sections[] = trim(substr($form_def, $section_start));
+
+		// cycle through form definition file (and possibly an existing article
+		// as well), finding template and field declarations and replacing them
+		// with form elements, either blank or pre-populated, as appropriate
+		$all_fields = array();
+		$data_text = "";
+		$template_name = "";
+		$allow_multiple = false;
+		$instance_num = 0;
+		$all_instances_printed = false;
+		$strict_parsing = false;
+		// initialize list of choosers (dropdowns with available templates)
+		$choosers = array();
+		for ($section_num = 0; $section_num < count($form_def_sections); $section_num++) {
+			$tif = new SFTemplateInForm();
+			$start_position = 0;
+			$template_text = "";
+			// the append is there to ensure that the original array doesn't get
+			// modified; is it necessary?
+			$section = " " . $form_def_sections[$section_num];
+
+			while ($brackets_loc = strpos($section, '{{{', $start_position)) {
+				$brackets_end_loc = strpos($section, "}}}", $brackets_loc);
+				$bracketed_string = substr($section, $brackets_loc + 3, $brackets_end_loc - ($brackets_loc + 3));
+				$tag_components = explode('|', $bracketed_string);
+				$tag_title = trim($tag_components[0]);
+				// =====================================================
+				// for template processing
+				// =====================================================
+				if ($tag_title == 'for template') {
+					$old_template_name = $template_name;
+					$template_name = trim($tag_components[1]);
+					$tif->template_name = $template_name;
+					$query_template_name = str_replace(' ', '_', $template_name);
+					// also replace periods with underlines, since that's what
+					// POST does to strings anyway
+					$query_template_name = str_replace('.', '_', $query_template_name);
+					$chooser_name = false;
+					$chooser_caption = false;
+					// cycle through the other components
+					for ($i = 2; $i < count($tag_components); $i++) {
+						$component = $tag_components[$i];
+						if ($component == 'multiple') $allow_multiple = true;
+						if ($component == 'strict') $strict_parsing = true;
+						$sub_components = explode('=', $component);
+						if (count($sub_components) == 2) {
+							if ($sub_components[0] == 'label') {
+								$template_label = $sub_components[1];
+							} elseif ($sub_components[0] == 'chooser') {
+								$allow_multiple = true;
+								$chooser_name = $sub_components[1];
+							} elseif ($sub_components[0] == 'chooser caption') {
+								$chooser_caption = $sub_components[1];
+							}
+						}
+					}
+					// if this is the first instance, add the label in the form
+					if (($old_template_name != $template_name) && isset($template_label)) {
+						// add a placeholder to the form text so the fieldset can be
+						// hidden if chooser support demands it
+						if ($chooser_name !== false)
+						$form_text .= "<fieldset [[placeholder]] haschooser=true>\n";
+						else
+						$form_text .= "<fieldset>\n";
+						$form_text .= "<legend>$template_label</legend>\n";
+					}
+					$template_text .= "{{" . $tif->template_name;
+					# reads all the fields of the template definition page
+					$all_fields = $tif->getAllFields();
+					// remove template tag
+					$section = substr_replace($section, '', $brackets_loc, $brackets_end_loc + 3 - $brackets_loc);
+					$template_instance_query_values = $wgRequest->getArray($query_template_name);
+					// if we are editing a page, and this template can be found more than
+					// once in that page, and multiple values are allowed, repeat this
+					// section
+					$existing_template_text = null;
+					// replace underlines with spaces in template name, to allow for
+					// searching on either
+					$search_template_str = str_replace('_', ' ', $tif->template_name);
+					if ($source_is_page || $form_is_partial) {
+						if ($allow_multiple) {
+							// find instances of this template in the page -
+							// if there's at least one, re-parse this section of the
+							// definition form for the subsequent template instances in
+							// this page; if there's none, don't include fields at all.
+							// there has to be a more efficient way to handle multiple
+							// instances of templates, one that doesn't involve re-parsing
+							// the same tags, but I don't know what it is.
+							if (stripos(str_replace('_', ' ', $existing_page_content), '{{' . $search_template_str) !== false) {
+								$instance_num++;
+							} else {
+								$all_instances_printed = true;
+							}
+						}
+						// get the first instance of this template on the page being edited,
+						// even if there are more
+						if (($start_char = stripos(str_replace('_', ' ', $existing_page_content), '{{' . $search_template_str)) !== false) {
+							$fields_start_char = $start_char + 2 + strlen($search_template_str);
+							// skip ahead to the first real character
+							while (in_array($existing_page_content[$fields_start_char], array(' ', '\n', '|'))) {
+								$fields_start_char++;
+							}
+							$template_contents = array('0' => '');
+							// cycle through template call, splitting it up by pipes ('|'),
+							// except when that pipe is part of a piped link
+							$field = "";
+							$uncompleted_square_brackets = 0;
+							$uncompleted_curly_brackets = 2;
+							$template_ended = false;
+							for ($i = $fields_start_char; ! $template_ended && ($i < strlen($existing_page_content)); $i++) {
+								$c = $existing_page_content[$i];
+								if ($c == '[') {
+									$uncompleted_square_brackets++;
+								} elseif ($c == ']' && $uncompleted_square_brackets > 0) {
+									$uncompleted_square_brackets--;
+								} elseif ($c == '{') {
+									$uncompleted_curly_brackets++;
+								} elseif ($c == '}' && $uncompleted_curly_brackets > 0) {
+									$uncompleted_curly_brackets--;
+								}
+								// handle an end to a field and/or template declaration
+								$template_ended = ($uncompleted_curly_brackets == 0 && $uncompleted_square_brackets == 0);
+								$field_ended = ($c == '|' && $uncompleted_square_brackets == 0);
+								if ($template_ended || $field_ended) {
+									// if this was the last character in the template, remove
+									// the closing curly brackets
+									if ($template_ended) {
+										$field = substr($field, 0, -1);
+									}
+									// either there's an equals sign near the beginning or not -
+									// handling is similar in either way; if there's no equals
+									// sign, the index of this field becomes the key
+									$sub_fields = explode('=', $field, 2);
+									if (count($sub_fields) > 1) {
+										$template_contents[trim($sub_fields[0])] = trim($sub_fields[1]);
+									} else {
+										$template_contents[] = trim($sub_fields[0]);
+									}
+									$field = '';
+								} else {
+									$field .= $c;
+								}
+							}
+							$existing_template_text = substr($existing_page_content, $start_char, $i - $start_char);
+							// now remove this template from the text being edited
+							// if this is a partial form, establish a new insertion point
+							if ($existing_page_content && $form_is_partial && $wgRequest->getCheck('partial')) {
+								// if something already exists, set the new insertion point
+								// to its position; otherwise just let it lie
+								if (strpos($existing_page_content, $existing_template_text) !== false) {
+									$existing_page_content = str_replace('{{{insertionpoint}}}', '', $existing_page_content);
+									$existing_page_content = str_replace($existing_template_text, '{{{insertionpoint}}}', $existing_page_content);
+								}
+							} else {
+								$existing_page_content = str_replace($existing_template_text, '', $existing_page_content);
+							}
+							// if this is not a multiple-instance template, and we've found
+							// a match in the source page, there's a good chance that this
+							// page was created with this form - note that, so we don't
+							// send the user a warning
+							// (multiple-instance templates have a greater chance of
+							// getting repeated from one form to the next)
+							if (! $allow_multiple) {
+								$source_page_matches_this_form = true;
+							}
+						}
+					}
+					// if the input is from the form (meaning the user has hit one
+					// of the bottom row of buttons), and we're dealing with a
+					// multiple template, get the values for this instance of this
+					// template, then delete them from the array, so we can get the
+					// next group next time - the next() command for arrays doesn't
+					// seem to work here
+					if ((! $source_is_page) && $allow_multiple && $wgRequest) {
+						$all_instances_printed = true;
+						if ($old_template_name != $template_name) {
+							$all_values_for_template = $wgRequest->getArray($query_template_name);
+						}
+						if ($all_values_for_template) {
+							$cur_key = key($all_values_for_template);
+							// skip the input coming in from the "starter" div
+							if ($cur_key == 'num') {
+								unset($all_values_for_template[$cur_key]);
+								$cur_key = key($all_values_for_template);
+							}
+							if ($template_instance_query_values = current($all_values_for_template)) {
+								$all_instances_printed = false;
+								unset($all_values_for_template[$cur_key]);
+							}
+						}
+					}
+					//  save the template name
+					$__fields['tmpl_name'] = $tif->template_name;
+					// =====================================================
+					// end template processing
+					// =====================================================
+				} elseif ($tag_title == 'end template') {
+					// remove this tag, reset some variables, and close off form HTML tag
+					$section = substr_replace($section, '', $brackets_loc, $brackets_end_loc + 3 - $brackets_loc);
+					$template_name = null;
+					if (isset($template_label)) {
+						$form_text .= "</fieldset>\n";
+						unset ($template_label);
+					}
+					$allow_multiple = false;
+					$all_instances_printed = false;
+					$instance_num = 0;
+					// if the hiding placeholder is still around, this fieldset should
+					// be hidden because it is empty and choosers are being used. So,
+					// hide it.
+					$form_text = str_replace("[[placeholder]]", "style='display:none'", $form_text);
+					// =====================================================
+					// field processing
+					// =====================================================
+				} elseif ($tag_title == 'field') {
+					$field_name = trim($tag_components[1]);
+					// cycle through the other components
+					$is_mandatory = false;
+					$is_hidden = false;
+					$is_restricted = false;
+					$is_uploadable = false;
+					$is_list = false;
+					$input_type = null;
+					$field_args = array();
+					$default_value = "";
+					$possible_values = null;
+					$preload_page = null;
+					for ($i = 2; $i < count($tag_components); $i++) {
+						$component = trim($tag_components[$i]);
+						if ($component == 'mandatory') {
+							$is_mandatory = true;
+						} elseif ($component == 'hidden') {
+							$is_hidden = true;
+						} elseif ($component == 'restricted') {
+							$is_restricted = true;
+						} elseif ($component == 'uploadable') {
+							$field_args['is_uploadable'] = true;
+						} elseif ($component == 'list') {
+							$is_list = true;
+						} elseif ($component == 'autocomplete') {
+							$field_args['autocomplete'] = true;
+						} elseif ($component == 'no autocomplete') {
+							$field_args['no autocomplete'] = true;
+						} elseif ($component == 'remote autocompletion') {
+							$field_args['remote autocompletion'] = true;
+						} else {
+							$sub_components = explode('=', $component);
+							if (count($sub_components) == 2) {
+								if ($sub_components[0] == 'input type') {
+									$input_type = $sub_components[1];
+								} elseif ($sub_components[0] == 'default') {
+									$default_value = $sub_components[1];
+								} elseif ($sub_components[0] == 'preload') {
+									// free text field has special handling
+									if ($field_name == 'free text' || $field_name = '<freetext>') {
+										$free_text_preload_page = $sub_components[1];
+									} else {
+										// this variable is not used
+										$preload_page = $sub_components[1];
+									}
+								} elseif ($sub_components[0] == 'values') {
+									$possible_values = explode(',', $sub_components[1]);
+								} elseif ($sub_components[0] == 'values from category') {
+									$possible_values = SFUtils::getAllPagesForCategory($sub_components[1], 10);
+								} elseif ($sub_components[0] == 'values from concept') {
+									$possible_values = SFUtils::getAllPagesForConcept($sub_components[1]);
+								} else {
+									$field_args[$sub_components[0]] = $sub_components[1];
+								}
+								// for backwards compatibility
+								if ($sub_components[0] == 'autocomplete on' && $sub_components[1] == null) {
+									$field_args['no autocomplete'] = true;
+								}
+							}
+						}
+					}
+					$field_args['part_of_multiple'] = $allow_multiple;
+					// get the value from the request, if it's there, and if it's not
+					// an array
+					$escaped_field_name = str_replace("'", "\'", $field_name);
+					if (isset($template_instance_query_values) &&
+					$template_instance_query_values != null &&
+					array_key_exists($escaped_field_name, $template_instance_query_values)) {
+						$field_query_val = $template_instance_query_values[$escaped_field_name];
+						if ($field_query_val && ! is_array($field_query_val)) {
+							$cur_value = $field_query_val;
+						}
+					} else
+					$cur_value = '';
+					if ($cur_value && ! is_array($cur_value)) {
+						# no escaping needed
+						// $cur_value = str_replace('"', '&quot;', $cur_value);
+						
+					}
+
+					if ($cur_value == null) {
+						// set to default value specified in the form, if it's there
+						$cur_value = $default_value;
+					}
+
+					// if the user is starting to edit a page, and that page contains
+					// the current template being processed, get the current template
+					// field's value in the existing page
+					if ($source_is_page && (! empty($existing_template_text))) {
+						if (isset($template_contents[$field_name])) {
+							$cur_value = $template_contents[$field_name];
+						} else
+						$cur_value = '';
+						if ($cur_value) {
+							# no escaping needed
+							// $cur_value = str_replace('"', '&quot;', $cur_value);
+						}
+					}
+
+					// handle the free text field - if it was declared as
+					// "field|free text" (a deprecated usage), it has to be outside
+					// of a template
+					if (($template_name == '' && $field_name == 'free text') ||
+					$field_name == '<freetext>') {
+						// add placeholders for the free text in both the form and
+						// the page, using <free_text> tags - once all the free text
+						// is known (at the end), it will get substituted in
+						if ($is_hidden) {
+							$new_text = SFFormUtils::hiddenFieldHTML('free_text', '<free_text>');
+						} else {
+							if (! array_key_exists('rows', $field_args))
+							$field_args['rows'] = 5;
+							if (! array_key_exists('cols', $field_args))
+							$field_args['cols'] = 80;
+							$sfgTabIndex++;
+							$sfgFieldNum++;
+							list($new_text, $new_javascript_text) = SFFormInputs::textAreaHTML('<free_text>', 'free_text', false, ($form_is_disabled || $is_restricted), $field_args);
+							$fields_javascript_text .= $new_javascript_text;
+						}
+						$free_text_was_included = true;
+						// add a similar placeholder to the data text
+						$data_text .= "<free_text>\n";
+					}
+
+					if ($template_name == '') {
+						$section = substr_replace($section, $new_text, $brackets_loc, $brackets_end_loc + 3 - $brackets_loc);
+					} else {
+						if (is_array($cur_value)) {
+							// first, check if it's a list
+							if (array_key_exists('is_list', $cur_value) &&
+							$cur_value['is_list'] == true) {
+								$cur_value_in_template = "";
+								if (array_key_exists('delimiter', $field_args)) {
+									$delimiter = $field_args['delimiter'];
+								} else {
+									$delimiter = ",";
+								}
+								foreach ($cur_value as $key => $val) {
+									if ($key !== "is_list") {
+										if ($cur_value_in_template != "") {
+											$cur_value_in_template .= $delimiter . " ";
+										}
+										$cur_value_in_template .= $val;
+									}
+								}
+							} else {
+								// otherwise:
+								// if it has 1 or 2 elements, assume it's a checkbox; if it has
+								// 3 elements, assume it's a date
+								// - this handling will have to get more complex if other
+								// possibilities get added
+								if (count($cur_value) == 1) {
+									// manually load SMW's message values here, in case they
+									// didn't get loaded before
+									wfLoadExtensionMessages('SemanticMediaWiki');
+									$words_for_false = explode(',', wfMsgForContent('smw_false_words'));
+									// for each language, there's a series of words that are
+									// equal to false - get the word in the series that matches
+									// "no"; generally, that's the third word
+									$index_of_no = 2;
+									if (count($words_for_false) > $index_of_no) {
+										$no = ucwords($words_for_false[$index_of_no]);
+									} elseif (count($words_for_false) == 0) {
+										$no = "0"; // some safe value if no words are found
+									} else {
+										$no = ucwords($words_for_false[0]);
+									}
+									$cur_value_in_template = $no;
+								} elseif (count($cur_value) == 2) {
+									wfLoadExtensionMessages('SemanticMediaWiki');
+									$words_for_true = explode(',', wfMsgForContent('smw_true_words'));
+									// get the value in the 'true' series that tends to be "yes",
+									// and go with that one - generally, that's the third word
+									$index_of_yes = 2;
+									if (count($words_for_true) > $index_of_yes) {
+										$yes = ucwords($words_for_true[$index_of_yes]);
+									} elseif (count($words_for_true) == 0) {
+										$yes = "1"; // some safe value if no words are found
+									} else {
+										$yes = ucwords($words_for_true[0]);
+									}
+									$cur_value_in_template = $yes;
+									// if it's 3 or greater, assume it's a date or datetime
+								} elseif (count($cur_value) >= 3) {
+									$month = $cur_value['month'];
+									$day = $cur_value['day'];
+									if ($day != '') {
+										global $wgAmericanDates;
+										if ($wgAmericanDates == false) {
+											// pad out day to always be two digits
+											$day = str_pad($day, 2, "0", STR_PAD_LEFT);
+										}
+									}
+									$year = $cur_value['year'];
+									if (isset($cur_value['hour'])) $hour = $cur_value['hour'];
+									if (isset($cur_value['minute'])) $minute = $cur_value['minute'];
+									if (isset($cur_value['second'])) $second = $cur_value['second'];
+									if (isset($cur_value['ampm24h'])) $ampm24h = $cur_value['ampm24h'];
+									if (isset($cur_value['timezone'])) $timezone = $cur_value['timezone'];
+									if ($month != '' && $day != '' && $year != '') {
+										// special handling for American dates - otherwise, just
+										// the standard year/month/day (where month is a number)
+										global $wgAmericanDates;
+										if ($wgAmericanDates == true) {
+											$cur_value_in_template = "$month $day, $year";
+										} else {
+											$cur_value_in_template = "$year/$month/$day";
+										}
+										// include whatever time information we have
+										if(isset($hour)) $cur_value_in_template .= " " . str_pad(intval(substr($hour,0,2)),2,'0',STR_PAD_LEFT) . ":" . str_pad(intval(substr($minute,0,2)),2,'0',STR_PAD_LEFT);
+										if(isset($second)) $cur_value_in_template .= ":" . str_pad(intval(substr($second,0,2)),2,'0',STR_PAD_LEFT);
+										if(isset($ampm24h)) $cur_value_in_template .= " $ampm24h";
+										if(isset($timezone)) $cur_value_in_template .= " $timezone";
+									} else {
+										$cur_value_in_template = "";
+									}
+								}
+							}
+						} else { // value is not an array
+							$cur_value_in_template = $cur_value;
+						}
+						if ($query_template_name == null || $query_template_name == '')
+						$input_name = $field_name;
+						elseif ($allow_multiple)
+						// 'num' will get replaced by an actual index, either in PHP
+						// or in Javascript, later on
+						$input_name = $query_template_name . '[num][' . $field_name . ']';
+						else
+						$input_name = $query_template_name . '[' . $field_name . ']';
+					
+						// disable this field if either the whole form is disabled, or
+						// it's a restricted field and user doesn't have sysop privileges
+						$is_disabled = ($form_is_disabled ||
+						($is_restricted && (! $wgUser || ! $wgUser->isAllowed('editrestrictedfields'))));
+						// create an SFFormTemplateField instance based on all the
+						// parameters in the form definition, and any information from
+						// the template definition (contained in the $all_fields parameter)
+
+						# creation of a form field from the definition page
+						$form_field = SFFormField::createFromDefinitionForSerialization($field_name, $input_name,
+						$is_mandatory, $is_hidden, $is_uploadable, $possible_values, $is_disabled,
+						$is_list, $input_type, $field_args, $all_fields, $strict_parsing);
+						// if this is not part of a 'multiple' template, incrememt the
+						// global tab index (used for correct tabbing)
+						if (! $field_args['part_of_multiple'])
+						$sfgTabIndex++;
+						// increment the global field number regardless
+						$sfgFieldNum++;
+						// if the field is a date field, and its default value was set
+						// to 'now', and it has no current value, set $cur_value to be
+						// the current date
+						if ($default_value == 'now' &&
+						// if the date is hidden, cur_value will already be set
+						// to the default value
+						($cur_value == '' || $cur_value == 'now')) {
+							if ($input_type == 'date' || $input_type == 'datetime' ||
+							$input_type == 'datetime with timezone' ||
+							($input_type == '' && $form_field->template_field->field_type == 'Date')) {
+								$cur_time = time();
+								$year = date("Y", $cur_time);
+								$month = date("n", $cur_time);
+								$day = date("j", $cur_time);
+								global $wgAmericanDates, $sfg24HourTime;
+								if ($wgAmericanDates == true) {
+									$month_names = SFFormUtils::getMonthNames();
+									$month_name = $month_names[$month - 1];
+									$cur_value_in_template = "$month_name $day, $year";
+								} else {
+									$cur_value_in_template = "$year/$month/$day";
+								}
+								if ($input_type ==  'datetime' || $input_type == 'datetime with timezone') {
+									if ($sfg24HourTime) {
+										$hour = str_pad(intval(substr(date("G", $cur_time),0,2)),2,'0',STR_PAD_LEFT);
+									} else {
+										$hour = str_pad(intval(substr(date("g", $cur_time),0,2)),2,'0',STR_PAD_LEFT);
+									}
+									$minute = str_pad(intval(substr(date("i", $cur_time),0,2)),2,'0',STR_PAD_LEFT);
+									$second = str_pad(intval(substr(date("s", $cur_time),0,2)),2,'0',STR_PAD_LEFT);
+									if ($sfg24HourTime) {
+										$cur_value_in_template .= " $hour:$minute:$second";
+									} else {
+										$ampm = date("A", $cur_time);
+										$cur_value_in_template .= " $hour:$minute:$second $ampm";
+									}
+								}
+								if ($input_type == 'datetime with timezone') {
+									$timezone = date("T", $cur_time);
+									$cur_value_in_template .= " $timezone";
+								}
+							}
+						}
+						// if the field is a text field, and its default value was set
+						// to 'current user', and it has no current value, set $cur_value
+						// to be the current user
+						if ($default_value == 'current user' &&
+						// if the date is hidden, cur_value will already be set
+						// to the default value
+						($cur_value == '' || $cur_value == 'current user')) {
+							if ($input_type == 'text' || $input_type == '') {
+								$cur_value_in_template = $wgUser->getName();
+								$cur_value = $cur_value_in_template;
+							}
+						}
+						
+						# field + field value
+						$form_field->cur_value = $cur_value;						
+						# possible_values hack
+						$__tmpValues = $form_field->template_field->possible_values;
+						$form_field->template_field->possible_values = array();
+						if($__tmpValues != NULL)
+						{
+							foreach ($__tmpValues as $key=>$value){
+							$form_field->template_field->possible_values["value".$key] = $value;
+							}
+						}						
+
+						$__fields["field".count($__fields)] = $this->toArray($form_field);
+						
+						$new_text = "dummy"; // set only in order to break						
+
+						if ($new_text) {
+							$section = substr_replace($section, $new_text, $brackets_loc, $brackets_end_loc + 3 - $brackets_loc);
+						} else {
+							$start_position = $brackets_end_loc;
+						}
+					}					
+				} else { // tag is not one of the three allowed values
+					// ignore tag
+					$start_position = $brackets_end_loc;
+				} // end if
+			} // end while
+
+		} // end for
+
+		// get free text, and add to page data, as well as retroactively
+		// inserting it into the form
+
+		// If $form_is_partial is true then either:
+		// (a) we're processing a replacement (param 'partial' == 1)
+		// (b) we're sending out something to be replaced (param 'partial' is missing)
+		if ($form_is_partial) {
+			if(!$wgRequest->getCheck('partial')) {
+				$free_text = $original_page_content;
+				$form_text .= SFFormUtils::hiddenFieldHTML('partial', 1);
+			} else {
+				$free_text = null;
+				$existing_page_content = preg_replace('/²\{(.*?)\}²/s', '{{\1}}', $existing_page_content);
+				$existing_page_content = preg_replace('/\{\{\{insertionpoint\}\}\}/', '', $existing_page_content);
+				$existing_page_content = Sanitizer::safeEncodeAttribute($existing_page_content);
+			}
+		} elseif ($source_is_page) {
+			// if the page is the source, free_text will just be whatever in the
+			// page hasn't already been inserted into the form
+			$free_text = trim($existing_page_content);
+			// or get it from a form submission
+		} elseif ($wgRequest->getCheck('free_text')) {
+			$free_text = $wgRequest->getVal('free_text');
+			if (! $free_text_was_included) {
+				$data_text .= "<free_text>";
+			}
+			// or get it from the form definition
+		} elseif ($free_text_preload_page != null) {
+			$free_text = SFFormUtils::getPreloadedText($free_text_preload_page);
+		} else {
+			$free_text = null;
+		}
+		# the free text is set here
+		// if the FCKeditor extension is installed, use that for the free text input
+		global $wgFCKEditorDir;
+		if ($wgFCKEditorDir) {
+			$showFCKEditor = SFFormUtils::getShowFCKEditor();
+			$free_text = htmlspecialchars( $free_text );
+			if($showFCKEditor & RTE_VISIBLE) {
+				$free_text = SFFormUtils::prepareTextForFCK($free_text);
+			}
+		} else {
+			$showFCKEditor = 0;
+			$free_text = Sanitizer::safeEncodeAttribute($free_text);
+		}
+		// now that we have it, substitute free text into the form and page
+		$form_text = str_replace('<free_text>', $free_text, $form_text);
+		$data_text = str_replace('<free_text>', $free_text, $data_text);
+
+		# return the fields		
+		return $__fields;
+	}  
 }
Index: extensions/SemanticForms/includes/SF_FormField.inc
===================================================================
--- extensions/SemanticForms/includes/SF_FormField.inc	(revision 3708)
+++ extensions/SemanticForms/includes/SF_FormField.inc	(working copy)
@@ -6,274 +6,319 @@
  * for that field that are set within the form
  */
 class SFFormField {
-	var $num;
-	var $template_field;
-	var $input_type;
-	var $is_mandatory;
-	var $is_hidden;
-	var $is_restricted;
-	var $possible_values;
-	// the following fields are not set by the form-creation page
-	// (though they could be)
-	var $is_uploadable;
-	var $field_args;
-	var $autocomplete_source;
-	var $autocomplete_field_type;
-	var $no_autocomplete;
-	var $part_of_multiple;
-	// somewhat of a hack - these two fields are for a field in a specific
-	// representation of a form, not the form definition; ideally these
-	// should be contained in a third 'field' class, called something like
-	// SFFormInstanceField, that holds these fields plus an instance of
-	// SFFormField. Too much work?
-	var $input_name;
-	var $is_disabled;
+    var $num;
+    var $template_field;
+    var $input_type;
+    var $is_mandatory;
+    var $is_hidden;
+    var $is_restricted;
+    var $possible_values;
+    // the following fields are not set by the form-creation page
+    // (though they could be)
+    var $is_uploadable;
+    var $field_args;
+    var $autocomplete_source;
+    var $autocomplete_field_type;
+    var $no_autocomplete;
+    var $part_of_multiple;
+    // somewhat of a hack - these two fields are for a field in a specific
+    // representation of a form, not the form definition; ideally these
+    // should be contained in a third 'field' class, called something like
+    // SFFormInstanceField, that holds these fields plus an instance of
+    // SFFormField. Too much work?
+    var $input_name;
+    var $is_disabled;
 
-	static function create($num, $template_field) {
-		$f = new SFFormField();
-		$f->num = $num;
-		$f->template_field = $template_field;
-		$f->input_type = "";
-		$f->is_mandatory = false;
-		$f->is_hidden = false;
-		$f->is_restricted = false;
-		$f->is_uploadable = false;
-		$f->possible_values = null;
-		return $f;
-	}
+    static function create($num, $template_field) {
+        $f = new SFFormField();
+        $f->num = $num;
+        $f->template_field = $template_field;
+        $f->input_type = "";
+        $f->is_mandatory = false;
+        $f->is_hidden = false;
+        $f->is_restricted = false;
+        $f->is_uploadable = false;
+        $f->possible_values = null;
+        return $f;
+    }
 
-	static function createFromDefinition($field_name, $input_name, $is_mandatory, $is_hidden, $is_uploadable, $possible_values, $is_disabled, $is_list, $input_type, $field_args, $all_fields, $strict_parsing) {
-		// see if this field matches one of the fields defined for this
-		// template - if it is, use all available information about
-		// that field; if it's not, either include it in the form or
-		// not, depending on whether the template has a 'strict'
-		// setting in the form definition
-		$the_field = null;
-		foreach ($all_fields as $cur_field) {
-			if ($field_name == $cur_field->field_name) {
-				$the_field = $cur_field;
-				break;
-			}
-		}
-		if ($the_field == null) {
-			if ($strict_parsing) {
-				$dummy_ff = new SFFormField();
-				$dummy_ff->template_field = new SFTemplateField();
-				$dummy_ff->is_list = false;
-				$dummy_ff->field_args = array();
-				return $dummy_ff;
-			}
-			$the_field = new SFTemplateField();
-		}
+    static function createFromDefinition($field_name, $input_name, $is_mandatory, $is_hidden, $is_uploadable, $possible_values, $is_disabled, $is_list, $input_type, $field_args, $all_fields, $strict_parsing) {
+        // see if this field matches one of the fields defined for this
+        // template - if it is, use all available information about
+        // that field; if it's not, either include it in the form or
+        // not, depending on whether the template has a 'strict'
+        // setting in the form definition
+        $the_field = null;
+        foreach ($all_fields as $cur_field) {
+            if ($field_name == $cur_field->field_name) {
+                $the_field = $cur_field;
+                break;
+            }
+        }
+        if ($the_field == null) {
+            if ($strict_parsing) {
+                $dummy_ff = new SFFormField();
+                $dummy_ff->template_field = new SFTemplateField();
+                $dummy_ff->is_list = false;
+                $dummy_ff->field_args = array();
+                return $dummy_ff;
+            }
+            $the_field = new SFTemplateField();
+        }
 
-		// create an SFFormField object, containing this field as well
-		// as settings from the form definition file
-		$f = new SFFormField();
-		$f->template_field = $the_field;
-		$f->is_mandatory = $is_mandatory;
-		$f->is_hidden = $is_hidden;
-		$f->is_uploadable = $is_uploadable;
-		$f->possible_values = $possible_values;
-		$f->input_type = $input_type;
-		$f->field_args = $field_args;
-		$f->input_name = $input_name;
-		$f->is_disabled = $is_disabled;
-		$f->is_list = $is_list;
-		return $f;
-	}
+        // create an SFFormField object, containing this field as well
+        // as settings from the form definition file
+        $f = new SFFormField();
+        $f->template_field = $the_field;
+        $f->is_mandatory = $is_mandatory;
+        $f->is_hidden = $is_hidden;
+        $f->is_uploadable = $is_uploadable;
+        $f->possible_values = $possible_values;
+        $f->input_type = $input_type;
+        $f->field_args = $field_args;
+        $f->input_name = $input_name;
+        $f->is_disabled = $is_disabled;
+        $f->is_list = $is_list;
+        return $f;
+    }
+    
+    /**
+     * Used by teh data API. 
+     */
+    function createFromDefinitionForSerialization($field_name, $input_name, $is_mandatory, $is_hidden, $is_uploadable, $possible_values, $is_disabled, $is_list, $input_type, $field_args, $all_fields, $strict_parsing) {
+        // see if this field matches one of the fields defined for this template -
+        // if it is, use all available information about that field; if it's not,
+        // either include it in the form or not, depending on whether the
+        // template has a 'strict' setting in the form definition
+        $the_field = null;
+        foreach ($all_fields as $cur_field) {
+            if ($field_name == $cur_field->field_name) {
+                $the_field = $cur_field;
+                break;
+            }
+        }
+        if ($the_field == null) {
+            if ($strict_parsing) {
+                $dummy_ftf = new SFFormField();
+                $dummy_ftf->template_field = new SFTemplateField();
+                $dummy_ftf->is_list = false;
+                $dummy_ftf->field_args = array();
+                return $dummy_ftf;
+            }
+            $the_field = new SFTemplateField();
+        }
 
-	/**
-	 * Get the set of possible form input types for either a specific
-	 * SMW property type or a list of such types
-	 */
-	function possibleInputTypes($semantic_type, $is_list) {
-		// first, get the list of field types, to determine which one this is
-		global $smwgContLang;
-		$datatypeLabels =  $smwgContLang->getDatatypeLabels();
-		$string_type = $datatypeLabels['_str'];
-		$text_type = $datatypeLabels['_txt'];
-		// type introduced in SMW 1.2
-		$code_type = array_key_exists('_cod', $datatypeLabels) ? $datatypeLabels['_cod'] : 'code';
-		$url_type = $datatypeLabels['_uri'];
-		$email_type = $datatypeLabels['_ema'];
-		$float_type = $datatypeLabels['_num'];
-		$int_type = $datatypeLabels['_num'];
-		$bool_type = $datatypeLabels['_boo'];
-		$date_type = $datatypeLabels['_dat'];
-		$enum_type = 'enumeration'; // not a real type
-		$page_type = $datatypeLabels['_wpg'];
+        // create an SFFormTemplateField object, containing this field as well
+        // as settings from the form definition file
+        $f = new SFFormField();
+        $f->template_field = $the_field;
+        $f->is_mandatory = $is_mandatory;
+        $f->is_hidden = $is_hidden;
+        $f->is_uploadable = $is_uploadable;
+        $f->possible_values = $possible_values;
+        $f->input_type = $input_type;       
+        //$f->input_name = $input_name; // not needed
+        $f->is_disabled = $is_disabled;
+        $f->is_list = $is_list;
+        // add field args directly
+        $f->autocomplete_category = $field_args['autocomplete on category'];
+        $f->part_of_multiple = $field_args['part_of_multiple'];
+        
+        return $f;
+    }
 
-		// then, return the array of possible input types, depending on
-		// the field type and whether this field will contain multiple
-		// values
-		if ($semantic_type == $string_type ||
-			$semantic_type == $float_type ||
-			$semantic_type == $int_type ||
-			$semantic_type == $url_type ||
-			$semantic_type == $email_type) {
-			if ($is_list) {
-				return array('text', 'textarea');
-			} else {
-				return array('text');
-			}
-		} elseif ($semantic_type == $text_type || $semantic_type == $code_type) {
-			return array('textarea');
-		} elseif ($semantic_type == $bool_type) {
-			return array('checkbox');
-		} elseif ($semantic_type == $date_type) {
-			return array('date', 'datetime', 'datetime with timezone', 'year');
-		} elseif ($semantic_type == $enum_type) {
-			if ($is_list) {
-				return array('checkboxes', 'listbox');
-			} else {
-				return array('dropdown', 'radiobutton');
-			}
-		} elseif ($semantic_type == $page_type) {
-			if ($is_list) {
-				return array('text', 'textarea');
-			} else {
-				return array('text');
-			}
-		} else { // blank or an unknown type
-			return array('text', 'textarea', 'checkbox', 'date', 'datetime', 'datetime with timezone');
-		}
-	}
+    /**
+     * Get the set of possible form input types for either a specific
+     * SMW property type or a list of such types
+     */
+    function possibleInputTypes($semantic_type, $is_list) {
+        // first, get the list of field types, to determine which one this is
+        global $smwgContLang;
+        $datatypeLabels =  $smwgContLang->getDatatypeLabels();
+        $string_type = $datatypeLabels['_str'];
+        $text_type = $datatypeLabels['_txt'];
+        // type introduced in SMW 1.2
+        $code_type = array_key_exists('_cod', $datatypeLabels) ? $datatypeLabels['_cod'] : 'code';
+        $url_type = $datatypeLabels['_uri'];
+        $email_type = $datatypeLabels['_ema'];
+        $float_type = $datatypeLabels['_num'];
+        $int_type = $datatypeLabels['_num'];
+        $bool_type = $datatypeLabels['_boo'];
+        $date_type = $datatypeLabels['_dat'];
+        $enum_type = 'enumeration'; // not a real type
+        $page_type = $datatypeLabels['_wpg'];
 
-	function inputTypeDropdownHTML($dropdown_name, $possible_input_types, $cur_input_type) {
-		// create the dropdown HTML for a list of possible input types
-		$text = "	<select name=\"$dropdown_name\">\n";
-		foreach ($possible_input_types as $i => $input_type) {
-			if ($i == 0) {
-				$text .= "	<option value=\"\">$input_type " .
-				wfMsg('sf_createform_inputtypedefault') . "</option>\n";
-			} else {
-				$selected_str = ($cur_input_type == $input_type) ? "selected" : "";
-				$text .= "	<option value=\"$input_type\" $selected_str>$input_type</option>\n";
-			}
-		}
-		$text .= "	</select>\n";
-		return $text;
-	}
+        // then, return the array of possible input types, depending on
+        // the field type and whether this field will contain multiple
+        // values
+        if ($semantic_type == $string_type ||
+            $semantic_type == $float_type ||
+            $semantic_type == $int_type ||
+            $semantic_type == $url_type ||
+            $semantic_type == $email_type) {
+            if ($is_list) {
+                return array('text', 'textarea');
+            } else {
+                return array('text');
+            }
+        } elseif ($semantic_type == $text_type || $semantic_type == $code_type) {
+            return array('textarea');
+        } elseif ($semantic_type == $bool_type) {
+            return array('checkbox');
+        } elseif ($semantic_type == $date_type) {
+            return array('date', 'datetime', 'datetime with timezone', 'year');
+        } elseif ($semantic_type == $enum_type) {
+            if ($is_list) {
+                return array('checkboxes', 'listbox');
+            } else {
+                return array('dropdown', 'radiobutton');
+            }
+        } elseif ($semantic_type == $page_type) {
+            if ($is_list) {
+                return array('text', 'textarea');
+            } else {
+                return array('text');
+            }
+        } else { // blank or an unknown type
+            return array('text', 'textarea', 'checkbox', 'date', 'datetime', 'datetime with timezone');
+        }
+    }
 
-	function creationHTML($template_num) {
-		$field_form_text = $template_num . "_" . $this->num;
-		$template_field = $this->template_field;
-		$text = '<h3>' . wfMsg('sf_createform_field') . " '" . $template_field->field_name . "'</h3>\n";
-		$prop_link_text = SFUtils::linkText(SMW_NS_PROPERTY, $template_field->semantic_property);
-		// TODO - remove this probably-unnecessary check?
-		if ($template_field->semantic_property == "") {
-			// print nothing if there's no semantic field
-		} elseif ($template_field->field_type == "") {
-			$text .= '<p>' . wfMsg('sf_createform_fieldpropunknowntype', $prop_link_text) . "</p>\n";
-		} elseif ($template_field->is_list) {
-			$text .= '<p>' . wfMsg('sf_createform_fieldproplist', $prop_link_text,
-				SFUtils::linkText(SMW_NS_TYPE, $template_field->field_type)) . "</p>\n";
-		} else {
-			$text .= '<p>' . wfMsg('sf_createform_fieldprop', $prop_link_text,
-				SFUtils::linkText(SMW_NS_TYPE, $template_field->field_type)) . "</p>\n";
-		}
-		// if it's not a semantic field - don't add any text
-		$form_label_text = wfMsg('sf_createform_formlabel');
-		$field_label = $template_field->label;
-		$input_type_text = wfMsg('sf_createform_inputtype');
-		$text .=<<<END
-	<p>$form_label_text <input type="text" name="label_$field_form_text" size=20 value="$field_label" />
-	&nbsp; $input_type_text
+    function inputTypeDropdownHTML($dropdown_name, $possible_input_types, $cur_input_type) {
+        // create the dropdown HTML for a list of possible input types
+        $text = "   <select name=\"$dropdown_name\">\n";
+        foreach ($possible_input_types as $i => $input_type) {
+            if ($i == 0) {
+                $text .= "  <option value=\"\">$input_type " .
+                wfMsg('sf_createform_inputtypedefault') . "</option>\n";
+            } else {
+                $selected_str = ($cur_input_type == $input_type) ? "selected" : "";
+                $text .= "  <option value=\"$input_type\" $selected_str>$input_type</option>\n";
+            }
+        }
+        $text .= "  </select>\n";
+        return $text;
+    }
+
+    function creationHTML($template_num) {
+        $field_form_text = $template_num . "_" . $this->num;
+        $template_field = $this->template_field;
+        $text = '<h3>' . wfMsg('sf_createform_field') . " '" . $template_field->field_name . "'</h3>\n";
+        $prop_link_text = SFUtils::linkText(SMW_NS_PROPERTY, $template_field->semantic_property);
+        // TODO - remove this probably-unnecessary check?
+        if ($template_field->semantic_property == "") {
+            // print nothing if there's no semantic field
+        } elseif ($template_field->field_type == "") {
+            $text .= '<p>' . wfMsg('sf_createform_fieldpropunknowntype', $prop_link_text) . "</p>\n";
+        } elseif ($template_field->is_list) {
+            $text .= '<p>' . wfMsg('sf_createform_fieldproplist', $prop_link_text,
+                SFUtils::linkText(SMW_NS_TYPE, $template_field->field_type)) . "</p>\n";
+        } else {
+            $text .= '<p>' . wfMsg('sf_createform_fieldprop', $prop_link_text,
+                SFUtils::linkText(SMW_NS_TYPE, $template_field->field_type)) . "</p>\n";
+        }
+        // if it's not a semantic field - don't add any text
+        $form_label_text = wfMsg('sf_createform_formlabel');
+        $field_label = $template_field->label;
+        $input_type_text = wfMsg('sf_createform_inputtype');
+        $text .=<<<END
+    <p>$form_label_text <input type="text" name="label_$field_form_text" size=20 value="$field_label" />
+    &nbsp; $input_type_text
 
 END;
-		$possible_input_types = $this->possibleInputTypes($template_field->field_type, $template_field->is_list);
-		if (count($possible_input_types) > 1) {
-			$text .= $this->inputTypeDropdownHTML("input_type_$field_form_text", $possible_input_types, $template_field->input_type);
-		} else {
-			$text .= $possible_input_types[0];
-		}
-		$mandatory_checked_str = ($this->is_mandatory) ? "checked" : "";
-		$mandatory_text = wfMsg('sf_createform_mandatory');
-		$hidden_checked_str = ($this->is_hidden) ? "checked" : "";
-		$hidden_text = wfMsg('sf_createform_hidden');
-		$restricted_checked_str = ($this->is_restricted) ? "checked" : "";
-		$restricted_text = wfMsg('sf_createform_restricted');
-		$text .=<<<END
-	</p>
-	<p>
-	<input type="checkbox" name="mandatory_$field_form_text" value="mandatory" $mandatory_checked_str /> $mandatory_text
-	<input type="checkbox" name="hidden_$field_form_text" value="hidden" $hidden_checked_str /> $hidden_text
-	<input type="checkbox" name="restricted_$field_form_text" value="restricted" $restricted_checked_str /> $restricted_text</p>
-	<hr>
+        $possible_input_types = $this->possibleInputTypes($template_field->field_type, $template_field->is_list);
+        if (count($possible_input_types) > 1) {
+            $text .= $this->inputTypeDropdownHTML("input_type_$field_form_text", $possible_input_types, $template_field->input_type);
+        } else {
+            $text .= $possible_input_types[0];
+        }
+        $mandatory_checked_str = ($this->is_mandatory) ? "checked" : "";
+        $mandatory_text = wfMsg('sf_createform_mandatory');
+        $hidden_checked_str = ($this->is_hidden) ? "checked" : "";
+        $hidden_text = wfMsg('sf_createform_hidden');
+        $restricted_checked_str = ($this->is_restricted) ? "checked" : "";
+        $restricted_text = wfMsg('sf_createform_restricted');
+        $text .=<<<END
+    </p>
+    <p>
+    <input type="checkbox" name="mandatory_$field_form_text" value="mandatory" $mandatory_checked_str /> $mandatory_text
+    <input type="checkbox" name="hidden_$field_form_text" value="hidden" $hidden_checked_str /> $hidden_text
+    <input type="checkbox" name="restricted_$field_form_text" value="restricted" $restricted_checked_str /> $restricted_text</p>
+    <hr>
 
 END;
-		return $text;
-	}
+        return $text;
+    }
 
-	// for now, HTML of an individual field depends on whether or not it's
-	// part of multiple-instance template; this may change if handling of
-	// such templates in form definitions gets more sophisticated
-	function createMarkup($part_of_multiple, $is_last_field_in_template) {
-		$text = "";
-		if ($this->template_field->label != "") {
-			if ($part_of_multiple) {
-				$text .= "'''" . $this->template_field->label .  ":''' ";
-			} else {
-				$text .= "! " . $this->template_field->label . ":\n";
-			}
-		}
-		if (! $part_of_multiple) { $text .= "| "; }
-		$text .= "{{{field|" . $this->template_field->field_name;
-		if ($this->template_field->input_type != '') {
-			$text .= "|input type=" . $this->template_field->input_type;
-		}
-		if ($this->is_mandatory) {
-			$text .= "|mandatory";
-		} elseif ($this->is_hidden) {
-			$text .= "|hidden";
-		} elseif ($this->is_restricted) {
-			$text .= "|restricted";
-		}
-		$text .= "}}}\n";
-		if ($part_of_multiple) {
-			$text .= "\n";
-		} elseif (! $is_last_field_in_template) {
-			$text .= "|-\n";
-		}
-		return $text;
-	}
+    // for now, HTML of an individual field depends on whether or not it's
+    // part of multiple-instance template; this may change if handling of
+    // such templates in form definitions gets more sophisticated
+    function createMarkup($part_of_multiple, $is_last_field_in_template) {
+        $text = "";
+        if ($this->template_field->label != "") {
+            if ($part_of_multiple) {
+                $text .= "'''" . $this->template_field->label .  ":''' ";
+            } else {
+                $text .= "! " . $this->template_field->label . ":\n";
+            }
+        }
+        if (! $part_of_multiple) { $text .= "| "; }
+        $text .= "{{{field|" . $this->template_field->field_name;
+        if ($this->template_field->input_type != '') {
+            $text .= "|input type=" . $this->template_field->input_type;
+        }
+        if ($this->is_mandatory) {
+            $text .= "|mandatory";
+        } elseif ($this->is_hidden) {
+            $text .= "|hidden";
+        } elseif ($this->is_restricted) {
+            $text .= "|restricted";
+        }
+        $text .= "}}}\n";
+        if ($part_of_multiple) {
+            $text .= "\n";
+        } elseif (! $is_last_field_in_template) {
+            $text .= "|-\n";
+        }
+        return $text;
+    }
 
-	/*
-	 * Since Semantic Forms uses a hook system for the functions that
-	 * create HTML inputs, most arguments are contained in the "$other_args"
-	 * array - create this array, using the attributes of this form
-	 * field and the template field it corresponds to, if any
-	 */
-	function getArgumentsForInputCall($default_args = null) {
-		// start with the arguments array already defined
-		$other_args = $this->field_args;
-		// a value defined for the form field should always supersede
-		// the coresponding value for the template field
-		if ($this->possible_values != null)
-			$other_args['possible_values'] = $this->possible_values;
-		else
-			$other_args['possible_values'] = $this->template_field->possible_values;
-		$other_args['is_list'] = ($this->is_list || $this->template_field->is_list);
-		if ($this->template_field->semantic_property != '' && ! array_key_exists('semantic_property', $other_args))
-			$other_args['semantic_property'] = $this->template_field->semantic_property;
-		// if autocompletion hasn't already been hardcoded in the form,
-		// and it's a property of type page, or a property of another
-		// type with 'autocomplete' specified, set the necessary
-		// parameters
-		if (! array_key_exists('autocompletion source', $other_args)) {
-			if ($this->template_field->propertyIsOfType('_wpg')) {
-				$other_args['autocompletion source'] = $this->template_field->semantic_property;
-				$other_args['autocomplete field type'] = 'relation';
-			} elseif (array_key_exists('autocomplete', $other_args) || array_key_exists('remote autocompletion', $other_args)) {
-				$other_args['autocompletion source'] = $this->template_field->semantic_property;
-				$other_args['autocomplete field type'] = 'attribute';
-			}
-		}
-		// now merge in the default values set by SFFormPrinter, if
-		// there were any - put the default values first, so that if
-		// there's a conflict they'll be overridden
-		if ($default_args != null)
-			$other_args = array_merge($default_args, $other_args);
-		return $other_args;
-	}
+    /*
+     * Since Semantic Forms uses a hook system for the functions that
+     * create HTML inputs, most arguments are contained in the "$other_args"
+     * array - create this array, using the attributes of this form
+     * field and the template field it corresponds to, if any
+     */
+    function getArgumentsForInputCall($default_args = null) {
+        // start with the arguments array already defined
+        $other_args = $this->field_args;
+        // a value defined for the form field should always supersede
+        // the coresponding value for the template field
+        if ($this->possible_values != null)
+            $other_args['possible_values'] = $this->possible_values;
+        else
+            $other_args['possible_values'] = $this->template_field->possible_values;
+        $other_args['is_list'] = ($this->is_list || $this->template_field->is_list);
+        if ($this->template_field->semantic_property != '' && ! array_key_exists('semantic_property', $other_args))
+            $other_args['semantic_property'] = $this->template_field->semantic_property;
+        // if autocompletion hasn't already been hardcoded in the form,
+        // and it's a property of type page, or a property of another
+        // type with 'autocomplete' specified, set the necessary
+        // parameters
+        if (! array_key_exists('autocompletion source', $other_args)) {
+            if ($this->template_field->propertyIsOfType('_wpg')) {
+                $other_args['autocompletion source'] = $this->template_field->semantic_property;
+                $other_args['autocomplete field type'] = 'relation';
+            } elseif (array_key_exists('autocomplete', $other_args) || array_key_exists('remote autocompletion', $other_args)) {
+                $other_args['autocompletion source'] = $this->template_field->semantic_property;
+                $other_args['autocomplete field type'] = 'attribute';
+            }
+        }
+        // now merge in the default values set by SFFormPrinter, if
+        // there were any - put the default values first, so that if
+        // there's a conflict they'll be overridden
+        if ($default_args != null)
+            $other_args = array_merge($default_args, $other_args);
+        return $other_args;
+    }
 }
Index: extensions/SemanticForms/includes/SF_GlobalFunctions.php
===================================================================
--- extensions/SemanticForms/includes/SF_GlobalFunctions.php	(revision 3708)
+++ extensions/SemanticForms/includes/SF_GlobalFunctions.php	(working copy)
@@ -10,6 +10,7 @@
 define('SF_VERSION','1.6');
 
 $wgExtensionCredits['specialpage'][]= array(
+	'path' => __FILE__,
 	'name' => 'Semantic Forms',
 	'version' => SF_VERSION,
 	'author' => 'Yaron Koren and others',
@@ -35,6 +36,7 @@
 $wgHooks['smwInitProperties'][] = 'SFUtils::initProperties';
 
 $wgAPIModules['sfautocomplete'] = 'SFAutocompleteAPI';
+$wgAPIModules['sfdata'] = 'SFDataAPI';
 
 // register all special pages and other classes
 $wgSpecialPages['Forms'] = 'SFForms';
@@ -83,6 +85,7 @@
 $wgAutoloadClasses['SFLinkUtils'] = $sfgIP . '/includes/SF_LinkUtils.inc';
 $wgAutoloadClasses['SFParserFunctions'] = $sfgIP . '/includes/SF_ParserFunctions.php';
 $wgAutoloadClasses['SFAutocompleteAPI'] = $sfgIP . '/includes/SF_AutocompleteAPI.php';
+$wgAutoloadClasses['SFDataAPI'] = $sfgIP . '/includes/SF_DataAPI.php';
 $wgJobClasses['createPage'] = 'SFCreatePageJob';
 $wgAutoloadClasses['SFCreatePageJob'] = $sfgIP . '/includes/SF_CreatePageJob.php';
 require_once($sfgIP . '/languages/SF_Language.php');
Index: extensions/SemanticForms/includes/SF_DataAPI.php
===================================================================
--- extensions/SemanticForms/includes/SF_DataAPI.php	(revision 0)
+++ extensions/SemanticForms/includes/SF_DataAPI.php	(revision 0)
@@ -0,0 +1,949 @@
+<?php
+/**
+ * Adds and handles the 'sfdata' action to the MediaWiki API.
+ *
+ * @author Dian
+ * @todo This is a patched version for SF 1.6. There might be some issues with "new" methods returning array instead of a single value, e.g. getDefaultForms.
+ */
+
+/**
+ * Protect against register_globals vulnerabilities.
+ * This line must be present before any global variable is referenced.
+ */
+if (!defined('MEDIAWIKI')) die();
+
+/**
+ * @addtogroup API
+ */
+class SFDataAPI extends ApiBase {
+
+	public function __construct($query, $moduleName) {
+		parent :: __construct($query, $moduleName);
+	}
+
+	public function execute() {
+
+		global $wgRequest;
+		$__params = $this->extractRequestParams();
+		$__data = array();
+
+		$__username = $__params['un'];
+		$__userId = $__params['uid'];
+		$__loginToken = $__params['lt'];
+
+		// only with GET
+		if($wgRequest->wasPosted() === false){
+			$__title = str_replace(' ', '_', $__params['title']);
+			$__revisionId = $__params['rid'];
+			$__catTree = str_replace(' ', '_', $__params['cattree']);
+			$__catLevel = $__params['catlevel'];
+			$__sfList = str_replace(' ', '_', $__params['sflist']);
+			$__pageList = str_replace(' ', '_', $__params['pagelist']);
+			$__substr = $__params['substr'];
+
+			if ($__title != ''){
+				$__data = $this->getSerializedForm($__title, $__revisionId, $__username, $__userId, $__loginToken);
+			}elseif ($__catTree != '') {
+				if ($__catTree == "root") $__catTree = "";
+				$__data = $this->getCategoryTree($__catTree, $__catLevel, $__substr);
+			}elseif ($__sfList != '') {
+				if ($__sfList == "root") $__sfList = "";
+				$__data = $this->getSFList($__sfList,$__substr);
+			}elseif ($__pageList != '') {
+				if ($__pageList == "root") $__pageList = "";
+				$__data = $this->getPageList($__pageList,$__substr);
+			}
+		}else{
+			// only with POST
+			$__serializedData = $__params['xmldata'];
+			$__methodType = $__params['mt'];
+
+			if ($__serializedData != NULL){
+				$__data = $this->setSerializedForm($__serializedData, $__methodType, $__username, $__userId, $__loginToken);
+			}
+		}
+
+		if (count($__data)<=0) {
+			return;
+		}
+
+		// Set top-level elements
+		$result = $this->getResult();
+		$result->setIndexedTagName($__data, 'p');
+		$result->addValue(null, $this->getModuleName(), $__data);
+	}
+
+	protected function getAllowedParams() {
+		return array (
+
+			'title' => null,
+			'rid' => null,
+			'xmldata' => null,
+			'mt' => null,			
+			'un' => null,
+			'uid' => null,
+			'lt' => null,
+			'cattree' => null,
+			'catlevel' => null,
+			'sflist' => null,
+			'pagelist' => null,
+			'substr' => null,
+		);
+	}
+
+	protected function getParamDescription() {
+		return array (
+			'title' => 'The title(s) of the page(s). Allowed only with a GET operation',
+			'rid' => 'The revision ID(s) of the page(s). Allowed only with a GET operation',
+			'xmldata' => 'The serialized data to be inserted in the wiki. Allowed only with a POST operation',						
+			'mt'	=> 'The method to be performed on the serialized data: c(reate)|u(pdate)|d(elete). Allowed only with a POST operation',
+			'un' => 'The username used',
+			'uid' => 'The user ID used',
+			'lt' => 'The login token used',
+			'cattree' => 'Category name used for the category tree. If "root" given starts with all toplevel categories.Allowed only with a GET operation',
+			'catlevel' => 'The level set when retrieving pages or the tree of categories for a category. Allowed only with a GET operation',
+			'sflist' => 'List of available SFs for a page. If "root" given returns all available SFs in the wiki. Allowed only with a GET operation',
+			'pagelist' => 'List of pages for a SF. If "root" given returns all available SFs in the wiki and teh pages using them. Allowed only with a GET operation',
+			'substr' => 'Search substring',
+		);
+	}
+
+	protected function getDescription() {
+		return 'Perform GET / POST operations on SFs - retrieving SF lists and serialized data. Used by the Semantic Forms extension (http://www.mediawiki.org/Extension:Semantic_Forms)';
+	}
+
+	protected function getExamples() {
+		return array (
+			'api.php?action=sfdata&title=John_Doe',	
+			'api.php?action=sfdata&substr=P&cattree=root&catlevel=3',
+			'api.php?action=sfdata&sflist=root',
+			'api.php?action=sfdata&pagelist=root',
+		);
+	}
+
+	/**
+	 * Reads the SF from the requested page and returns the form as an array ready for serialization. Works for both SF definitions and "normal" pages.
+	 *
+	 * @todo Currently reads only one SF instance per page. Add support for mutiple forms. For multiple instances add the <mfi name="formname"> element.
+	 * @param string $title The title(s) of the page(s) (namespace included).
+	 * @param string $revisionId The revision IDs of the page(s).
+	 * @param string $username The username provided.
+	 * @param string $userId The user ID provided.
+	 * @param string $loginToken The login token provided.
+	 * @return array An associative array of the resulting SF(s).
+	 */
+	public function getSerializedForm($title, $revisionId, $username = NULL, $userId = NULL, $loginToken = NULL){
+		$__pageReader = new PCPServer();
+		$__page = $__pageReader->readPage(new PCPUserCredentials($username, NULL, $userId, $loginToken),$title, $revisionId);
+		if (strpos($title,':') !=false){
+			list($__ns, $__title) = split(':', $__page->title);
+		}else{
+			$__title = $title;
+		}
+
+		$__result['page']['title'] = $__title;
+		$__result['page']['ns'] = $__page->namespace;
+		$__result['page']['rid'] = $__page->usedrevid;
+
+		$__formNames = SFLinkUtils::getFormsForArticle(new Article(Title::newFromText($__title, $__page->namespace)));
+		if( count($__formNames) > 0 ){
+			$__formName = $__formNames[0];
+			global $sfgFormPrinter,$wgContLang;
+
+			if($__page->namespace != SF_NS_FORM){
+				if ($__formName !== NULL && $__formName != ""){
+					$__result['page'][str_ireplace(' ','_',$__formName)] = $sfgFormPrinter->formSerialize(
+					$__pageReader->readPage(NULL,$wgContLang->getNsText(SF_NS_FORM) . ':' . $__formName)->text,
+					true,
+					$__page->text, $title);
+				}
+			}else{
+				$__result['page'][str_ireplace(' ','_',$__title)] = $sfgFormPrinter->formSerialize(
+				$__page->text,
+				false,
+				$__page->text, $title);
+			}
+		}
+			return($__result);
+	}
+
+	/**
+	 * Reads serialized data in XML format and saves the requested chages.
+	 *
+	 * @param XMLchunk $sfdata The posted data including page and SF attributes.
+	 * @param string $methodType The action to be performed: c(create) or u(update) or d(delete).
+	 * @param string $username The username provided.
+	 * @param string $userId The user ID provided.
+	 * @param string $loginToken The login token provided.
+	 */
+	public function setSerializedForm($sfdata, $methodType, $username = NULL, $userId = NULL, $loginToken = NULL){
+		$__xmlData = $this->XML2Array($sfdata, false);
+		$__serverUtility = new PCPServer();
+		$__userCredentials = new PCPUserCredentials(
+		$username,
+		NULL,
+		$userId,
+		$loginToken);
+
+		$__pageNs = utf8_decode($__xmlData['sfdata']['page']['@attributes']['ns']);
+		$__pageTitle = $__xmlData['sfdata']['page']['@attributes']['title'];
+		$__pageRId = $__xmlData['sfdata']['page']['@attributes']['rid'];
+		$__page = $__serverUtility->readPage(
+		$__userCredentials,
+		$__pageTitle,
+		$__pageRId);
+
+		if(stristr($methodType,"c")){ // the requested method is create
+			if($__page->pageid == NULL || $__page->pageid == ""){
+				// the page doesn't exist so we have to create it
+				// the XML data is read and a template is created for each SF
+
+				// since @array will be read together with the SF elements unset it
+				unset($__xmlData['sfdata']['page']['@attributes']);
+				$__sfNames = array_keys($__xmlData['sfdata']['page']);
+				$__tmplString = ""; // used for the creation of all template strings
+				$__tmplNames = ""; // used for adding addtional info to the summary
+
+				foreach ($__sfNames  as $__sfName){
+					$__sf = $__xmlData['sfdata']['page'][$__sfName];
+
+					if (isset($__sf['@attributes']) && isset($__sf['@attributes']['mfi'])){
+						// multiple SF instancies detected - multiple SFs to be saved in one request
+						// TODO: implement
+
+					}else{
+						// build the template string for each SF element
+						$__tmplString .= "\n{{".utf8_decode($__sf['@attributes']['tmpl_name'])."\n"; // the tempalte name
+						$__tmplNames .= utf8_decode($__sf['@attributes']['tmpl_name'])."\t";
+						// since @array will be read together with the SF field elements unset it
+						unset($__sf['@attributes']);
+
+						foreach ($__sf as $__field){ // in the SF element are listed all SF fields
+							// add the field name and value to the template
+							$__tmplString .= "|".utf8_decode($__field['@attributes']['field_name'])."=".utf8_decode($__field['@attributes']['cur_value'])."\n";
+						}
+						$__tmplString .= "}}\n"; // add closing brackets to the template
+					}
+				}
+
+				return $__serverUtility->createPage(
+				$__userCredentials,
+				$__pageTitle,
+				$__tmplString,
+				"SF data added to the page via the SF API. Templates:\t".$__tmplNames
+				);
+
+			}else{
+				// create the POM object for the requested page
+				$__pom = new POMPage(
+				$__pageTitle,
+				$__page->text,
+				array('POMExtendedParser'));
+
+				// since @array will be read together with the SF elements unset it
+				unset($__xmlData['sfdata']['page']['@attributes']);
+				$__sfNames = array_keys($__xmlData['sfdata']['page']);
+				$__tmplString = $__pom->text; // used for the creation of all template strings - preserve the existing page text if any
+				$__tmplNames = ""; // used for adding addtional info to the summary
+
+				foreach ($__sfNames  as $__sfName){
+					$__sf = $__xmlData['sfdata']['page'][$__sfName];
+					$__iterator = $__pom->getTemplateByTitle($__sf['@attributes']['tmpl_name'])->listIterator();
+
+					if (isset($__sf['@attributes']) && isset($__sf['@attributes']['mfi'])){
+						// multiple SF instances detected
+						// TODO: implement
+
+					}else{
+						if($__iterator->hasNext()){
+							// there is already a template defined and no multiple templates per page are supported
+							$this->dieUsage("Request cancelled. Page $__pageTitle already uses the semantic form $__sfName.", 'param_xmldata');
+						}else{
+							// build the template string for each SF element
+							$__tmplString .= "\n{{".utf8_decode($__sf['@attributes']['tmpl_name'])."\n"; // the tempalte name
+							$__tmplNames .= utf8_decode($__sf['@attributes']['tmpl_name'])."\t";
+							// since @array will be read together with the SF field elements unset it
+							unset($__sf['@attributes']);
+
+							foreach ($__sf as $__field){ // in the SF element are listed all SF fields
+								// add the field name and value to the template
+								$__tmplString .= "|".utf8_decode($__field['@attributes']['field_name'])."=".utf8_decode($__field['@attributes']['cur_value'])."\n";
+							}
+							$__tmplString .= "}}\n"; // add closing brackets to the template
+						}
+					}
+				}
+
+				return $__serverUtility->updatePage(
+				$__userCredentials,
+				$__pageTitle,
+				$__tmplString,
+				"SF data added to the page via the SF API. Templates:\t".$__tmplNames
+				);
+			}
+
+		}
+		if(stristr($methodType,"u")){ // the requested method is update
+			if($__page->pageid != NULL && $__page->pageid != ""){ // the page exists
+				// create the POM object for the requested page
+				$__pom = new POMPage(
+				$__pageTitle,
+				$__page->text,
+				array('POMExtendedParser'));
+
+				// since @array will be read together with the SF elements unset it
+				unset($__xmlData['sfdata']['page']['@attributes']);
+				$__sfNames = array_keys($__xmlData['sfdata']['page']);
+
+				foreach ($__sfNames  as $__sfName){
+					$__sf = $__xmlData['sfdata']['page'][$__sfName];
+					$__iterator = $__pom->getTemplateByTitle(utf8_decode($__sf['@attributes']['tmpl_name']))->listIterator();
+
+					if (isset($__sf['@attributes']) && isset($__sf['@attributes']['mfi'])){
+						// multiple SF instances detected
+						// TODO: implement
+
+					}else{
+						$__template = &$__iterator->getNextNodeValueByReference(); # get reference for direct changes
+						// since @array will be read together with the SF field elements unset it
+						unset($__sf['@attributes']);
+
+						foreach ($__sf as $__field){ // in the SF element are listed all SF fields
+							if($__template->getParameter(utf8_decode($__field['@attributes']['field_name']))!== NULL){
+								$__paramValue = &$__template->getParameterValue(utf8_decode($__field['@attributes']['field_name']));
+								$__paramValue = new POMSimpleText(utf8_decode($__field['@attributes']['cur_value']));
+							}
+						}
+					}
+				}
+				$__pom->sync();
+
+				return $__serverUtility->updatePage(
+				$__userCredentials,
+				$__pageTitle,
+				$__pom->text
+				);
+
+			}else{ // the page does not exist
+				$this->dieUsage("Request cancelled. Page ".$__pageTitle." does not exist.", 'param_xmldata');
+			}
+		}
+		if(stristr($methodType,"d")){ // the requested method is delete
+			if($__page->pageid != NULL && $__page->pageid != ""){ // the page exists
+				// create the POM object for the requested page
+				$__pom = new POMPage(
+				$__pageTitle,
+				$__page->text,
+				array('POMExtendedParser'));
+
+				// since @array will be read together with the SF elements unset it
+				unset($__xmlData['sfdata']['page']['@attributes']);
+				$__sfNames = array_keys($__xmlData['sfdata']['page']);
+
+				foreach ($__sfNames  as $__sfName){
+					$__sf = $__xmlData['sfdata']['page'][$__sfName];
+					$__iterator = $__pom->getTemplateByTitle(utf8_decode($__sf['@attributes']['tmpl_name']))->listIterator();
+
+					if (isset($__sf['@attributes']) && isset($__sf['@attributes']['mfi'])){
+						// multiple SF instances detected
+						// TODO: implement
+
+					}else{
+						$__template = &$__iterator->getNextNodeValueByReference(); # get reference for direct changes
+						$__template = new POMSimpleText("");
+					}
+				}
+				$__pom->sync();
+
+				return $__serverUtility->updatePage(
+				$__userCredentials,
+				$__pageTitle,
+				$__pom->text
+				);
+
+			}else{ // the page does not exist
+				$this->dieUsage("Request cancelled. Page ".$__pageTitle." does not exist.", 'param_xmldata');
+			}
+		}
+		return "";
+	}
+
+	public function getVersion() {
+		return __CLASS__ . ': $Id$';
+	}
+
+	/**
+	 * Converts an XML string to an associative array.
+	 *
+	 * @param string $xml
+	 * @param boolean $recursive
+	 * @return array The resulting array.
+	 */
+	private function XML2Array ( $xml , $recursive = false )
+	{
+		if ( $recursive )
+		{
+			$__array = $xml;
+
+		}
+		else
+		{
+			$__array = simplexml_load_string ( $xml );
+		}
+
+		$__newArray = array ();
+		$__array = ( array ) $__array;
+		foreach ( $__array as $__key => $__value )
+		{
+			$__value = ( array ) $__value ;
+			if ( isset ( $__value [ 0 ] ) )
+			{
+				$__newArray [ $__key ] = trim ( $__value [ 0 ] ) ;
+			}
+			else
+			{
+				$__newArray [ $__key ] = $this->XML2Array ( $__value , true ) ;
+			}
+		}
+		return $__newArray;
+	}
+
+	/**
+	 * Gets the category tree based on a category name and sublevel number.
+	 * The resulting array consists of:
+	 * * the category name
+	 * * catOptions child element having: SF=<sfname>|ROOT(the root point for categories - not a category itself)
+	 * * children: the subcategories (based on the number sublevels)
+	 *
+	 * @param string $catName The starting category name.
+	 * @param integer $sublevels The sublevels to eb checked. If the sublevel is equal 0, all sublevels are returned.
+	 * @param string $substring Substring check upon category names.
+	 * @return associativeArray The tree of categories.
+	 */
+	public function getCategoryTree($catName, $sublevels = 1, $substring){
+		global $smwgDefaultStore, $sfgFormPrinter;
+		$__store = smwfGetSemanticStore();
+
+		$__catHashmap = array(); // the resulting associative array
+		$__tmpCats = array(); // temporary category name list
+
+		if ($sublevels <0) {// safety check
+			$__catHashmap[str_ireplace(' ','_',$catName)] = array();
+			return $__catHashmap;
+		}
+
+		// get the direct subcategores for the requested category
+		// if the category name is empty get the root categories
+		if ($catName != '' && $catName != NULL){
+			$__tmpCats = $__store->getDirectSubCategories(Title::newFromText($catName, NS_CATEGORY));
+			if ($substring != ''){ // add only category names matching the substring
+				foreach ($__tmpCats as $__tmpCat){
+					if (stristr($__tmpCat->getText(), $substring) !== false){
+						$__catHashmap[str_ireplace(' ','_',$catName)][str_ireplace(' ','_',$__tmpCat->getText())] = array();
+					}
+				}
+			}else{
+				foreach ($__tmpCats as $__tmpCat){
+					$__catHashmap[str_ireplace(' ','_',$catName)][str_ireplace(' ','_',$__tmpCat->getText())] = array();
+				}
+			}
+			// check if there is a SF defined for the category
+			$__sfName = SFLinkUtils::getDefaultForms($catName, NS_CATEGORY);
+			if ( $__sfName != NULL){
+				$__catHashmap[str_ireplace(' ','_',$catName)]['catOptions'] = "Form:$__sfName";
+			}
+		}else{
+			$catName = 'root';
+
+			// check if the substring is defined
+			$__tmpCats = $__store->getRootCategories();
+			if ($substring != ''){ // add only category names matching the substring
+				foreach ($__tmpCats as $__tmpCat){
+					if (stristr($__tmpCat->getText(), $substring) !== false){
+						$__catHashmap[$catName][str_ireplace(' ','_',$__tmpCat->getText())] = array();
+					}
+				}
+			}else{
+				foreach ($__tmpCats as $__tmpCat){
+					$__catHashmap[$catName][str_ireplace(' ','_',$__tmpCat->getText())] = array();
+				}
+			}
+			$__catHashmap[$catName]['catOptions'] = "ROOT";
+		}
+
+		// now check for the requested sublevels
+		$__subcatCnt = count($__catHashmap[str_ireplace(' ','_',$catName)]);
+		if ($__subcatCnt>0 && array_key_exists('catOptions', $__catHashmap[str_ireplace(' ','_',$catName)])){
+			$__subcatCnt--; // decrease the counter if catOptions is set
+		}
+		if( $__subcatCnt ){
+			if ($sublevels >1 ){
+				foreach ($__catHashmap[str_ireplace(' ','_',$catName)] as $__subCategory=>$__emptySpace){
+					if($__subCategory != 'catOptions'){
+						$__catHashmap[str_ireplace(' ','_',$catName)] = array_merge( $__catHashmap[str_ireplace(' ','_',$catName)], $this->toArray($this->getCategoryTree($__subCategory, $sublevels-1, $substring)));
+					}
+
+				}
+			}elseif($sublevels == 1){
+				foreach ($__catHashmap[str_ireplace(' ','_',$catName)] as $__subCategory=>$__emptySpace){
+					if($__subCategory != 'catOptions'){
+						// check if there is a SF defined for the subcategories only if no further levels requested
+						$__sfName = SFLinkUtils::getDefaultForms($__subCategory, NS_CATEGORY);
+						if ( $__sfName != NULL){
+							$__catHashmap[str_ireplace(' ','_',$catName)][str_ireplace(' ','_',$__subCategory)]['catOptions'] = "Form:$__sfName";
+						}
+						$__catHashmap[str_ireplace(' ','_',$catName)][str_ireplace(' ','_',$__subCategory)] = array();
+					}
+				}
+
+			}elseif($sublevels == 0){
+				foreach ($__catHashmap[str_ireplace(' ','_',$catName)] as $__subCategory=>$__emptySpace){
+					if($__subCategory != 'catOptions'){
+						$__catHashmap[str_ireplace(' ','_',$catName)] = array_merge( $__catHashmap[str_ireplace(' ','_',$catName)], $this->toArray($this->getCategoryTree($__subCategory, $sublevels, $substring)));
+					}
+
+				}
+			}
+		}
+		return $__catHashmap;
+	}
+
+	/**
+	 * Gets a list of all available SFs for a page or for the whole wiki.
+	 *
+	 * @param string $page The namespace:title of the page or ''(blank) for all SFs in the wiki
+	 * @param string $substring Subtsting to search upon in the names of the SFs.
+	 * @return array A list of SF names.
+	 */
+	public function getSFList($page, $substring){
+		$__sfList = array();
+		$__tmpListAlternateSF = array();
+		$__tmpDefaultSF = NULL;
+
+		if(strstr($page, ':') !== false){
+			list($__pageNamespace,$__pageTitle) = split(':', $page);
+		}else{
+			$__pageTitle = $page;
+		}
+
+		if($__pageTitle == ''){
+			// return all SFs, top element is 'root'
+			$__tmpList = SFUtils::getAllForms();
+
+			if($substring != '' ) {
+				// check if the substring matches
+				foreach ($__tmpList as $__tmpListEntry){
+					if (stristr($__tmpListEntry, $substring) !== false){
+						$__sfList['root'][str_ireplace(' ','_',$__tmpListEntry)] = array();
+					}
+				}
+			}else{
+				foreach ($__tmpList as $__tmpListEntry){
+					$__sfList['root'][str_ireplace(' ','_',$__tmpListEntry)] = array();
+				}
+			}
+		}else{
+			// get all SFs for the particular page
+			// TODO: does alternate include the default form?
+			global $wgContLang;
+			// retrieve the store first
+			$__store = smwfGetSemanticStore();
+
+			// first determine which categories the page is assigned to
+			$__pageCats = $__store->getCategoriesForInstance(
+			Title::newFromText($__pageTitle, $wgContLang->getLocalNsIndex($__pageNamespace)));
+
+			// for each category only a default form should exist
+			foreach ($__pageCats as $__pageCat){
+				$__tmpDefaultSFs = SFLinkUtils::getDefaultForms($__pageCat->getText(), NS_CATEGORY);
+				if(count($__tmpDefaultSFs)> 0){
+					$__tmpDefaultSF = $__tmpDefaultSFs[0];
+					if($substring != '' ) {
+						// check if the substring matches
+						if (stristr($__tmpDefaultSF, $substring) !== false){
+							$__sfList[$__pageTitle]['def'][str_ireplace(' ','_',$__tmpDefaultSF)] = array();
+						}
+					}else{
+						$__sfList[$__pageTitle]['def'][str_ireplace(' ','_',$__tmpDefaultSF)] = array();
+					}
+				}
+			}
+			$__tmpDefaultSF = NULL;
+
+			// change the store - getProperties is supported by the SMW store only ...
+			$__store = smwfGetStore();
+
+
+			// second determine which properties are defined on the page
+			// default forms are only set via categories
+			$__semData  = $__store->getSemanticData(Title::newFromText($__pageTitle, $wgContLang->getLocalNsIndex($__pageNamespace)));
+			$__pageProps = $__semData->getProperties();
+
+			// for each property a default and alternate forms may exist
+			foreach ($__pageProps as $__pageProp){
+				if($__pageProp->isVisible()){ // exclude internal set properties
+					$__tmpListAlternateSF = SFLinkUtils::getAlternateForms(
+					$__pageProp->getWikiPageValue()->getTitle()->getText(),
+					$__pageProp->getWikiPageValue()->getNamespace());
+					$__tmpDefaultSFs = SFLinkUtils::getDefaultForms(
+					$__pageProp->getWikiPageValue()->getTitle()->getText(),
+					$__pageProp->getWikiPageValue()->getNamespace());
+
+					if(count($__tmpDefaultSFs) > 0){
+							
+						$__tmpDefaultSF = $__tmpDefaultSFs[0];
+
+						if($substring != '' ) {
+							// check if the substring matches
+							foreach ($__tmpListAlternateSF as $__tmpListEntry){
+								if (stristr($__tmpListEntry, $substring) !== false){
+									$__sfList[$__pageTitle]['alt'][str_ireplace(' ','_',$__tmpListEntry)] = array();
+								}
+							}
+							// ... and for the default form
+							if (stristr($__tmpDefaultSF, $substring) !== false){
+								$__sfList[$__pageTitle]['alt'][str_ireplace(' ','_',$__tmpDefaultSF)] = array();
+							}
+						}else{
+							foreach ($__tmpListAlternateSF as $__tmpListEntry){
+								$__sfList[$__pageTitle]['alt'][str_ireplace(' ','_',$__tmpListEntry)] = array();
+							}
+							if($__tmpDefaultSF != NULL){
+								$__sfList[$__pageTitle]['alt'][str_ireplace(' ','_',$__tmpDefaultSF)] = array();
+							}
+						}
+					}
+				}
+			}
+		}
+		return $__sfList;
+	}
+
+	/**
+	 * Gets all pages for a specific SF. The pages returned have an instance of the requested SF defined.
+	 *
+	 * @param string $sfName The name of the SF.
+	 * @param string $substring Subtsting to search upon in the names of the SFs.
+	 * @return array A list of page names.
+	 */
+	public function getPageList($sfName, $substring){
+
+		$__pageList = array();
+		$__serverUtility = new PCPServer();
+		$__store = smwfGetStore();
+
+		if(strstr($sfName, ':') !== false){
+			list($__sfNamespace,$__sfTitle) = split(':', $sfName);
+		}else{
+			$__sfTitle = $sfName;
+		}
+
+		if($__sfTitle == ''){
+			// search for all SFs
+			$__tmpList = SFUtils::getAllForms();
+
+			// categories or properties which use a spcific SF
+			// the structure is $__referencingAnnotations['root']['FORMNAME'][NS-NUMBER]['PAGETITLE']
+			// 				    $__referencingAnnotations['root']['FORMNAME']['sfobj']
+			$__referencingAnnotations = array();
+
+			// first: get all categories / properties that have the SF as default form
+			foreach ($__tmpList as $__tmpSF){
+				// workaround: trigger an ASK query
+				$__queryobj = SMWQueryProcessor::createQuery("[[Has default form::$__tmpSF]]", array());
+				$__queryobj->querymode = SMWQuery::MODE_INSTANCES;
+				$__res = smwfGetStore()->getQueryResult($__queryobj);
+				$__resCount = $__res->getCount();
+
+				for($__i=0; $__i<$__resCount;$__i++){
+					$__resArray = $__res->getNext();// SMWResultArray[]
+
+					foreach($__resArray as $__resElement){ // object from class SMWResultArray
+						$__tmpArr = $__resElement->getContent(); // SMWWikiPageValue[]
+						$__resPage = $__tmpArr[0]; // object from class SMWWikiPageValue - only 1 element is expected
+						$__referencingAnnotations[$__tmpSF][$__resPage->getNamespace()][$__resPage->getText()] = $__resPage->getTitle();
+					}
+
+				}
+			}
+
+			// second: get all categories / properties that have the SF as an alternate form
+			$__queryobj = array();
+			$__res = array();
+			foreach ($__tmpList as $__tmpSF){
+				// workaround: trigger an ASK query
+				$__queryobj = SMWQueryProcessor::createQuery("[[Has alternate form::$__tmpSF]]", array());
+				$__queryobj->querymode = SMWQuery::MODE_INSTANCES;
+				$__res = smwfGetStore()->getQueryResult($__queryobj);
+				$__resCount = $__res->getCount();
+
+				for($__i=0; $__i<$__resCount;$__i++){
+					$__resArray = $__res->getNext();// SMWResultArray[]
+
+					foreach($__resArray as $__resElement){ // object from class SMWResultArray
+						$__tmpArr = $__resElement->getContent(); // SMWWikiPageValue[]
+						$__resPage = $__tmpArr[0]; // object from class SMWWikiPageValue - only 1 element is expected
+						$__referencingAnnotations[$__tmpSF][$__resPage->getNamespace()][$__resPage->getText()] = $__resPage->getTitle();
+					}
+
+				}
+				// now add the SF structure
+				// we need at first the template title, but in future even comparision based on fields is possible
+				if(isset($__referencingAnnotations[$__tmpSF][$__resPage->getNamespace()])){
+					$__referencingAnnotations[$__tmpSF]['sfobj'] = $this->serializedForm($__tmpSF);
+				}
+			}
+
+			// now determine the pages using the found categories / properties
+
+			foreach(array_keys($__referencingAnnotations) as $__sformName){
+				$__sfCategories = $__referencingAnnotations[$__sformName][NS_CATEGORY];
+				$__sfProperties = $__referencingAnnotations[$__sformName][SMW_NS_PROPERTY];
+
+				// build a complex ASK query for all categories and properties
+				$__complexQuery = '';
+				if(isset($__sfCategories))
+				if ($__sfCategories !==NULL){
+					foreach (array_keys($__sfCategories) as $__sfCategory){
+						if($__complexQuery !== ''){
+							$__complexQuery.= "OR [[Category:$__sfCategory]]";
+						}else{
+							$__complexQuery.= "[[Category:$__sfCategory]]";
+						}
+					}
+				}
+				if(isset($__sfProperties))
+				if($__sfProperties !== NULL){
+					foreach (array_keys($__sfProperties) as $__sfProperty){
+						if($__complexQuery !== ''){
+							$__complexQuery.= " OR [[$__sfProperty::+]]";
+						}else{
+							$__complexQuery.= "[[$__sfProperty::+]]";
+						}
+					}
+				}
+
+				$__queryobj = SMWQueryProcessor::createQuery($__complexQuery, array());
+				$__queryobj->querymode = SMWQuery::MODE_INSTANCES;
+				$__res = smwfGetStore()->getQueryResult($__queryobj);
+				$__resCount = $__res->getCount();
+
+				for($__i=0; $__i<$__resCount;$__i++){
+					$__resArray = $__res->getNext();// SMWResultArray[]
+
+					foreach($__resArray as $__resElement){ // object from class SMWResultArray
+						$__tmpArr = $__resElement->getContent(); // SMWWikiPageValue[]
+						$__resPage = $__tmpArr[0]; // object from class SMWWikiPageValue - only 1 element is expected
+
+						// check if the substring matches
+						if($substring != ''){
+							if(stristr($__resPage->getText(), $substring)){
+								// now read the POM of each page and search for the template used by the SF
+								$__pcpPage= $__serverUtility->readPage(
+								NULL,
+								$__resPage->getText());
+								$__pom = new POMPage(
+								$__resPage->getText(),
+								$__pcpPage->text,
+								array('POMExtendedParser'));
+
+								// search for the template
+								$__iterator = $__pom->getTemplateByTitle($__referencingAnnotations[$__sformName]['sfobj']['tmpl_name'])->listIterator();
+								if($__iterator->hasNext())
+								{
+									$__pageList['root'][str_replace(" ", "_",$__sformName)][str_replace(" ", "_", $__resPage->getText())] = array();
+									$__pageList['root'][str_replace(" ", "_",$__sformName)][str_replace(" ", "_", $__resPage->getText())]['ns'] = $__pcpPage->ns;
+									$__pageList['root'][str_replace(" ", "_",$__sformName)][str_replace(" ", "_", $__resPage->getText())]['rid'] = $__pcpPage->lastrevid;
+								}
+							}
+						}else{
+							// now read the POM of each page and search for the template used by the SF
+							$__pcpPage= $__serverUtility->readPage(
+							NULL,
+							$__resPage->getText());
+							$__pom = new POMPage(
+							$__resPage->getText(),
+							$__pcpPage->text,
+							array('POMExtendedParser'));
+
+							// search for the template
+							$__iterator = $__pom->getTemplateByTitle($__referencingAnnotations[$__sformName]['sfobj']['tmpl_name'])->listIterator();
+							if($__iterator->hasNext())
+							{
+								$__pageList['root'][str_replace(" ", "_",$__sformName)][str_replace(" ", "_", $__resPage->getText())] = array();
+								$__pageList['root'][str_replace(" ", "_",$__sformName)][str_replace(" ", "_", $__resPage->getText())]['ns'] = $__pcpPage->ns;
+								$__pageList['root'][str_replace(" ", "_",$__sformName)][str_replace(" ", "_", $__resPage->getText())]['rid'] = $__pcpPage->lastrevid;
+							}
+						}
+					}
+				}
+			}
+		}else{
+			// search only for a single SF
+
+			// categories or properties which use a spcific SF
+			// the structure is $__referencingAnnotations['FORMNAME'][NS-NUMBER]['PAGETITLE']
+			// 				    $__referencingAnnotations['FORMNAME']['sfobj']
+			$__referencingAnnotations = array();
+
+
+			// first: get all categories / properties that have the SF as default form
+			// workaround: trigger an ASK query
+			$__queryobj = SMWQueryProcessor::createQuery("[[Has default form::$__sfTitle]]", array());
+			$__queryobj->querymode = SMWQuery::MODE_INSTANCES;
+			$__res = smwfGetStore()->getQueryResult($__queryobj);
+			$__resCount = $__res->getCount();
+
+			for($__i=0; $__i<$__resCount;$__i++){
+				$__resArray = $__res->getNext();// SMWResultArray[]
+
+				foreach($__resArray as $__resElement){ // object from class SMWResultArray
+					$__tmpArr = $__resElement->getContent(); // SMWWikiPageValue[]
+					$__resPage = $__tmpArr[0]; // object from class SMWWikiPageValue - only 1 element is expected
+					$__referencingAnnotations[$__sfTitle][$__resPage->getNamespace()][$__resPage->getText()] = $__resPage->getTitle();
+				}
+
+			}
+
+
+			// second: get all categories / properties that have the SF as an alternate form
+			$__queryobj = array();
+			$__res = array();
+			// workaround: trigger an ASK query
+			$__queryobj = SMWQueryProcessor::createQuery("[[Has alternate form::$__sfTitle]]", array());
+			$__queryobj->querymode = SMWQuery::MODE_INSTANCES;
+			$__res = smwfGetStore()->getQueryResult($__queryobj);
+			$__resCount = $__res->getCount();
+
+			for($__i=0; $__i<$__resCount;$__i++){
+				$__resArray = $__res->getNext();// SMWResultArray[]
+
+				foreach($__resArray as $__resElement){ // object from class SMWResultArray
+					$__tmpArr = $__resElement->getContent(); // SMWWikiPageValue[]
+					$__resPage = $__tmpArr[0]; // object from class SMWWikiPageValue - only 1 element is expected
+					$__referencingAnnotations[$__sfTitle][$__resPage->getNamespace()][$__resPage->getText()] = $__resPage->getTitle();
+				}
+
+			}
+			// now add the SF structure
+			// we need at first the template title, but in future even comparision based on fields is possible
+			if(isset($__referencingAnnotations[$__sfTitle][$__resPage->getNamespace()])){
+				$__referencingAnnotations[$__sfTitle]['sfobj'] = $this->serializedForm($__sfTitle);
+			}
+
+
+			// now determine the pages using the found categories / properties
+
+			$__sfCategories = $__referencingAnnotations[$__sfTitle][NS_CATEGORY];
+			$__sfProperties = $__referencingAnnotations[$__sfTitle][SMW_NS_PROPERTY];
+
+			// build a complex ASK query for all categories and properties
+			$__complexQuery = '';
+			if(isset($__sfCategories))
+			foreach (array_keys($__sfCategories) as $__sfCategory){
+				if($__complexQuery !== ''){
+					$__complexQuery.= "OR [[Category:$__sfCategory]]";
+				}else{
+					$__complexQuery.= "[[Category:$__sfCategory]]";
+				}
+			}
+
+			if(isset($__sfProperties))
+			foreach (array_keys($__sfProperties) as $__sfProperty){
+				if($__complexQuery !== ''){
+					$__complexQuery.= " OR [[$__sfProperty::+]]";
+				}else{
+					$__complexQuery.= "[[$__sfProperty::+]]";
+				}
+			}
+
+			$__queryobj = SMWQueryProcessor::createQuery($__complexQuery, array());
+			$__queryobj->querymode = SMWQuery::MODE_INSTANCES;
+			$__res = smwfGetStore()->getQueryResult($__queryobj);
+			$__resCount = $__res->getCount();
+
+			for($__i=0; $__i<$__resCount;$__i++){
+				$__resArray = $__res->getNext();// SMWResultArray[]
+
+				foreach($__resArray as $__resElement){ // object from class SMWResultArray
+					$__tmpArr = $__resElement->getContent(); // SMWWikiPageValue[]
+					$__resPage = $__tmpArr[0]; // object from class SMWWikiPageValue - only 1 element is expected
+
+					// check if the substring matches
+					if($substring != ''){
+						if(stristr($__resPage->getText(), $substring)){
+							// now read the POM of each page and search for the template used by the SF
+							$__pcpPage= $__serverUtility->readPage(
+							NULL,
+							$__resPage->getText());
+							$__pom = new POMPage(
+							$__resPage->getText(),
+							$__pcpPage->text,
+							array('POMExtendedParser'));
+
+							// search for the template
+							$__iterator = $__pom->getTemplateByTitle($__referencingAnnotations[$__sfTitle]['sfobj']['tmpl_name'])->listIterator();
+							if($__iterator->hasNext())
+							{
+								$__pageList[str_replace(" ", "_", $__sfTitle)][str_replace(" ", "_", $__resPage->getText())] = array();
+								$__pageList[str_replace(" ", "_", $__sfTitle)][str_replace(" ", "_", $__resPage->getText())]['ns'] = $__pcpPage->ns;
+								$__pageList[str_replace(" ", "_", $__sfTitle)][str_replace(" ", "_", $__resPage->getText())]['rid'] = $__pcpPage->lastrevid;
+							}
+						}
+					}else{
+						// now read the POM of each page and search for the template used by the SF
+						$__pcpPage= $__serverUtility->readPage(
+						NULL,
+						$__resPage->getText());
+						$__pom = new POMPage(
+						$__resPage->getText(),
+						$__pcpPage->text,
+						array('POMExtendedParser'));
+
+						// search for the template
+						$__iterator = $__pom->getTemplateByTitle($__referencingAnnotations[$__sfTitle]['sfobj']['tmpl_name'])->listIterator();
+						if($__iterator->hasNext())
+						{
+							$__pageList[str_replace(" ", "_", $__sfTitle)][str_replace(" ", "_", $__resPage->getText())] = array();
+							$__pageList[str_replace(" ", "_", $__sfTitle)][str_replace(" ", "_", $__resPage->getText())]['ns'] = $__pcpPage->ns;
+							$__pageList[str_replace(" ", "_", $__sfTitle)][str_replace(" ", "_", $__resPage->getText())]['rid'] = $__pcpPage->lastrevid;
+						}
+					}
+				}
+			}
+		}
+		return $__pageList;
+	}
+
+	private function serializedForm($title){
+		$__pageReader = new PCPServer();
+		$__page = $__pageReader->readPage(NULL,"Form:".$title);
+
+		global $sfgFormPrinter;
+
+		return $sfgFormPrinter->formSerialize(
+		$__page->text,
+		false,
+		$__page->text, $title);
+	}
+
+	/**
+	 * Converts simple data (e.g. string) into arrays
+	 *
+	 * @param somedata $data
+	 * @return array
+	 */
+	private function toArray($data)
+	{
+		if(is_array($data) || is_object($data))
+		{
+
+		}else{
+			$__result[$data] = '';
+			return $__result;
+		}
+		return $data;
+	}
+}
+
+
